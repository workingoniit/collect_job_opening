from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import threading
from selenium.common.exceptions import NoSuchElementException, TimeoutException, ElementClickInterceptedException, \
    StaleElementReferenceException
from datetime import datetime
import gspread


# 필요한 경우 옵션 추가
options = webdriver.ChromeOptions()
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')
options.add_argument('--disable-gpu')  # 만약 GPU 관련 문제가 있을 경우
driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

url = 'https://jasoseol.com/recruit'
driver.get(url)

popup_thread_running = True


def popup_watcher():
    global popup_thread_running
    start_time = time.time()  # 시작 시간 기록
    # while True:
    while popup_thread_running:
        try:
            # 예기치 않은 팝업 닫기
            popup_close_button = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.XPATH, '/html/body/div[1]/div/div/div/div[1]/div[2]/div[4]/button[1]'))
            )
            popup_close_button.click()
            print("팝업창을 닫았습니다.")
            driver.find_element(By.XPATH, "//img[contains(@class, 'image-icon')]").click()
            print("채용공고 재클릭")
            chat_close_button = WebDriverWait(driver, 20).until(
                EC.element_to_be_clickable((By.XPATH, '/html/body/div/div[1]/div[1]/div[3]/div[2]/div[4]'))
            )
            chat_close_button.click()

            # 팝업을 닫는 데 성공했으므로 함수 종료
            print("팝업 감시를 종료합니다.")

            popup_thread_running = False

            return  # 함수 종료

        except (NoSuchElementException, TimeoutException):
            # 팝업이 없으면 계속 진행
            pass

        except StaleElementReferenceException:
            # StaleElementReferenceException 발생 시 요소를 다시 찾기 위해 재시도
            print("StaleElementReferenceException 발생: 요소를 다시 찾습니다.")
            continue  # 루프를 다시 시작하여 요소를 다시 찾음

        # 10초가 지나면 감시 종료
        if time.time() - start_time > 10:
            print("10초 동안 팝업이 나타나지 않았습니다. 팝업 감시를 종료합니다.")
            popup_thread_running = False  # 감시 중지 플래그 설정
            return

        time.sleep(1)  # 매 1초마다 검사


# 백그라운드로 팝업 감시 쓰레드 실행
popup_thread = threading.Thread(target=popup_watcher)
popup_thread.daemon = True  # 메인 프로그램 종료 시 쓰레드도 자동으로 종료되도록 설정
popup_thread.start()

# 백그라운드로 팝업 감시 쓰레드 실행
popup_thread = threading.Thread(target=popup_watcher)
popup_thread.daemon = True  # 메인 프로그램 종료 시 쓰레드도 자동으로 종료되도록 설정
popup_thread.start()


def chat_delete():
    chat_close_button = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, '/html/body/div/div[1]/div[1]/div[3]/div[2]/div[4]/img'))
    )
    chat_close_button.click()
    print("채팅창을 닫았습니다.")


chat_delete()


# 1. '직무' 버튼 클릭
def click_job():
    job_button = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//div[@class='filter-summary-content']//input[@placeholder='직무 선택']"))
    )
    job_button.click()


# 2. 'IT·인터넷' 항목 클릭
it_internet_button_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[1]/div/div[4]/div[2]'

attempt = 0
while attempt < 5:  # 최대 5번 시도
    try:
        it_internet_button = WebDriverWait(driver, 5).until(
            EC.element_to_be_clickable((By.XPATH, it_internet_button_xpath))
        )
        it_internet_button.click()
        break  # 클릭 성공 시 반복 종료
    except TimeoutException:
        click_job()
        attempt += 1  # 클릭 실패 시 시도 횟수 증가

web_development_checkbox_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[2]/div[2]/div[1]/div[3]/div[1]/img'
web_development_checkbox = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, web_development_checkbox_xpath)))
web_development_checkbox.click()

web_development_checkbox_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[2]/div[2]/div[1]/div[4]/div[1]/img'
web_development_checkbox = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, web_development_checkbox_xpath)))
web_development_checkbox.click()

web_development_checkbox_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[2]/div[2]/div[1]/div[5]/div[1]/img'
web_development_checkbox = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, web_development_checkbox_xpath)))
web_development_checkbox.click()

web_development_checkbox_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[2]/div[2]/div[1]/div[6]/div[1]/img'
web_development_checkbox = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, web_development_checkbox_xpath)))
web_development_checkbox.click()

web_development_checkbox_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[2]/div[2]/div[1]/div[7]/div[1]/img'
web_development_checkbox = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, web_development_checkbox_xpath)))
web_development_checkbox.click()

web_development_checkbox_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div[4]/div[1]/div[2]/div/div/div[2]/div/div[2]/div[2]/div[1]/div[8]/div[1]/img'
web_development_checkbox = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, web_development_checkbox_xpath)))
web_development_checkbox.click()

# 다시 직무 버튼 클릭
click_job()


# 1. 오늘 날짜의 셀 찾기
today = datetime.now().day
# 2. 오늘 날짜에 해당하는 셀 찾기
# 개발자 도구를 통해 확인한 XPATH와 today 변수를 활용해 동적으로 찾음
today_xpath = f'//div[contains(@class, "day-label") and contains(@class, "today") and text()="{today}"]'
# 오늘 날짜 셀을 찾을 때까지 대기
today_element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.XPATH, today_xpath)))

# 스크롤하여 오늘 날짜 셀로 이동
driver.execute_script("arguments[0].scrollIntoView();", today_element)

# 3. 오늘 날짜 셀 내부의 회사 목록 찾기
# 새로운 XPATH 사용: 회사 이름이 포함된 'a' 태그를 찾음
company_elements_xpath = f'{today_xpath}/following-sibling::div[contains(@class, "day-content")]//a[contains(@class, "company")]'
company_elements = WebDriverWait(driver, 20).until(
    EC.presence_of_all_elements_located((By.XPATH, company_elements_xpath)))

data_for_sheet = []

# 2. 회사 목록 순회하며 정보 추출
for company in company_elements:
    this_company = {'company': ' ', 'title': ' ', 'positions': 'X', 'start': ' ', 'end': ' ', 'link': ' '}

    # 정확한 XPath를 사용하여 회사 이름 왼쪽의 모듈(네모 모양)의 텍스트를 찾습니다.
    try:
        # '시'라는 텍스트가 포함된 요소를 찾는 정확한 XPath 사용
        status_element = company.find_element(By.XPATH,
                                              './/div[contains(@class, "calendar-label") and contains(text(), "시")]')
        status_text = status_element.text.strip()  # '시' 또는 '끝'이 들어 있는 텍스트
    except NoSuchElementException:
        continue  # 모듈이 없으면 다음 회사로 넘어감

    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", company)

    attempt = 0
    while attempt < 5:  # 최대 5번 시도
        try:
            WebDriverWait(driver, 5).until(EC.element_to_be_clickable(company))
            company.click()
            break  # 클릭 성공 시 반복 종료
        except ElementClickInterceptedException:
            # JavaScript를 사용해 클릭 시도
            driver.execute_script("arguments[0].click();", company)
        except TimeoutException:
            attempt += 1  # 클릭 실패 시 시도 횟수 증가

    WebDriverWait(driver, 10).until(
        EC.visibility_of_element_located((By.XPATH, '//div[contains(@class, "modal-content")]')))

    # 첫 번째 회사의 초반 요소가 안 긁히는 경우가 많아서 1초 기다리기
    time.sleep(1)

    # 1. 회사 이름 추출
    company_name = driver.find_element(By.XPATH, '//div[@class="ec-name ng-binding"]').text
    if company_name:
        this_company['company'] = company_name
    # 1-1. 채용공고 이름 추출
    title = driver.find_element(By.XPATH,
                                '/html/body/div[1]/div[1]/div[2]/div/div[4]/div/div[2]/div/div/div[2]/recruit-slide/div[1]/div[1]/div[2]/div/div[1]').text
    if title:
        this_company['title'] = title

    # 2. 모든 직무 리스트 가져오기
    job_roles_elements = driver.find_elements(By.XPATH, '//td[@class="field ng-binding"]')

    # 3. '신입' 조건을 만족하는 직무 필터링
    filtered_job_roles = []
    for job_role_element in job_roles_elements:
        job_role_text = job_role_element.text

        # 직무 이름에 키워드가 포함되어 있는지 검사
        keywords = ['SW', '소프트웨어', 'AI', 'Data', '개발', '정보', '디지털', 'Digital', 'IT', '전산',
                    '정보', 'Back-end', '백엔드', '시스템', 'System', '데이터', 'Developer', '서버', 'Server']

        # 조건: '신입' 포함 및 키워드 일치
        if any(keyword.lower() in job_role_text.lower() for keyword in keywords):
            # 신입/경력 정보가 '신입'인 경우 필터링
            division_text = job_role_element.find_element(By.XPATH,
                                                          './preceding-sibling::td[@class="division ng-binding"]').text
            if '신입' in division_text:
                filtered_job_roles.append(job_role_text)

    if filtered_job_roles:
        this_company['positions'] = ', '.join(f for f in filtered_job_roles)

    # 4. 채용 기간 추출
    # XPath를 사용하여 요소가 로드될 때까지 최대 20초 기다림
    try:
        element = WebDriverWait(driver, 5).until(
            EC.presence_of_element_located((By.XPATH, '//div[contains(@class, "ec-date")]/div'))
        )
        period = element.text
        if period:
            start, end = period.split(' ~ ')
            end = end.split(' (')[0]
            this_company['start'], this_company['end'] = start, end
    except TimeoutException:
        print("요소를 찾는 데 시간이 너무 오래 걸렸습니다.")
        period = " "


    # 5. 채용 사이트 링크 추출
    try:
        # 고정된 버튼의 정확한 XPath를 입력하세요.
        button_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[4]/div/div[2]/div/div/div[2]/recruit-slide/div[1]/div[1]/div[4]/a'  # 여기에 고정된 버튼의 정확한 XPath를 넣으세요.

        # 버튼이 클릭 가능할 때까지 기다렸다가 클릭합니다.
        fixed_button = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, button_xpath)))
        fixed_button.click()

        # 새로운 탭이 열리기를 기다립니다.
        # 여기서 시간이 오래걸릴 때가 많아서 여유있게 기다림
        WebDriverWait(driver, 20).until(EC.number_of_windows_to_be(2))  # 2는 열린 탭의 개수

        # 현재 모든 윈도우 핸들을 저장합니다.
        original_window = driver.current_window_handle
        all_windows = driver.window_handles

        # 새로운 탭으로 전환합니다.
        for window in all_windows:
            if window != original_window:
                driver.switch_to.window(window)
                break

        # 새로운 탭의 URL을 가져옵니다.
        recruitment_site = driver.current_url
        this_company['link'] = recruitment_site

        # URL을 가져왔으면 원래 탭으로 돌아갑니다.
        driver.close()  # 새 탭을 닫습니다.
        driver.switch_to.window(original_window)

    except TimeoutException:
        print("채용 사이트 버튼을 찾거나 클릭하는 데 실패했습니다.")
        recruitment_site = " "

    data_for_sheet.append(list(this_company.values()))

    # 출력
    print(f'회사명: {company_name}, 제목: {title}, 직무: {filtered_job_roles}, 기한: {period}, 채용공고: {recruitment_site}')

    # 팝업 닫기
    close_button = driver.find_element(By.XPATH, '//img[@class="x-button"]')
    close_button.click()

popup_thread.join()  # 팝업 감시 쓰레드가 종료될 때까지 대기

driver.quit()


def append_data_to_sheet(worksheet, data):
    # 시트의 현재 데이터 수를 기준으로 다음 빈 행을 찾습니다
    next_row = len(worksheet.get_all_values()) + 1
    # 데이터를 업데이트할 위치를 찾습니다.
    worksheet.update(data, f'A{next_row}')


# 스프레드시트에 데이터 추가하기

key_file_path = '/Users/seyeon/Documents/gcp-job-crawling-projectKey/quixotic-moment-434117-b4-555dfd6f7330.json'
gc = gspread.service_account(key_file_path)
spreadsheet_url = 'https://docs.google.com/spreadsheets/d/1kmfudYmhKCRRtwM2E44mAmcyxng_fvx0QSZwhC5u7Go/edit?pli=1&gid=0#gid=0'
doc = gc.open_by_url(spreadsheet_url)

worksheet = doc.get_worksheet(0)
data = data_for_sheet
print("데이터", data)

append_data_to_sheet(worksheet, data)

